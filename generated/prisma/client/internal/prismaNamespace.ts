
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models.js"
import { type PrismaClient } from "./class.js"

export type * from '../models.js'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.0.0
 * Query Engine version: 0c19ccc313cf9911a90d99d2ac2eb0280c76c513
 */
export const prismaVersion: PrismaVersion = {
  client: "7.0.0",
  engine: "0c19ccc313cf9911a90d99d2ac2eb0280c76c513"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  User: 'User',
  PricingPlan: 'PricingPlan',
  Subscription: 'Subscription',
  Payment: 'Payment',
  Patient: 'Patient',
  MedicalHistory: 'MedicalHistory',
  FamilyHistory: 'FamilyHistory',
  Lifestyle: 'Lifestyle',
  Allergy: 'Allergy',
  Doctor: 'Doctor',
  PatientDoctor: 'PatientDoctor',
  Consultation: 'Consultation',
  Appointment: 'Appointment',
  Disease: 'Disease',
  PatientDisease: 'PatientDisease',
  ActiveSubstance: 'ActiveSubstance',
  DiseaseActiveSubstanceWarning: 'DiseaseActiveSubstanceWarning',
  MedicineAlternative: 'MedicineAlternative',
  TradeName: 'TradeName',
  Company: 'Company',
  ContractingCompany: 'ContractingCompany',
  ContractingCompanyTradeName: 'ContractingCompanyTradeName',
  Prescription: 'Prescription',
  PrescriptionVersion: 'PrescriptionVersion',
  DrugInteractionAlert: 'DrugInteractionAlert',
  Notification: 'Notification',
  AuditLog: 'AuditLog',
  Session: 'Session'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "user" | "pricingPlan" | "subscription" | "payment" | "patient" | "medicalHistory" | "familyHistory" | "lifestyle" | "allergy" | "doctor" | "patientDoctor" | "consultation" | "appointment" | "disease" | "patientDisease" | "activeSubstance" | "diseaseActiveSubstanceWarning" | "medicineAlternative" | "tradeName" | "company" | "contractingCompany" | "contractingCompanyTradeName" | "prescription" | "prescriptionVersion" | "drugInteractionAlert" | "notification" | "auditLog" | "session"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    User: {
      payload: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.UserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    PricingPlan: {
      payload: Prisma.$PricingPlanPayload<ExtArgs>
      fields: Prisma.PricingPlanFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PricingPlanFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PricingPlanPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PricingPlanFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PricingPlanPayload>
        }
        findFirst: {
          args: Prisma.PricingPlanFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PricingPlanPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PricingPlanFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PricingPlanPayload>
        }
        findMany: {
          args: Prisma.PricingPlanFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PricingPlanPayload>[]
        }
        create: {
          args: Prisma.PricingPlanCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PricingPlanPayload>
        }
        createMany: {
          args: Prisma.PricingPlanCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PricingPlanCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PricingPlanPayload>[]
        }
        delete: {
          args: Prisma.PricingPlanDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PricingPlanPayload>
        }
        update: {
          args: Prisma.PricingPlanUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PricingPlanPayload>
        }
        deleteMany: {
          args: Prisma.PricingPlanDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PricingPlanUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PricingPlanUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PricingPlanPayload>[]
        }
        upsert: {
          args: Prisma.PricingPlanUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PricingPlanPayload>
        }
        aggregate: {
          args: Prisma.PricingPlanAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePricingPlan>
        }
        groupBy: {
          args: Prisma.PricingPlanGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PricingPlanGroupByOutputType>[]
        }
        count: {
          args: Prisma.PricingPlanCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PricingPlanCountAggregateOutputType> | number
        }
      }
    }
    Subscription: {
      payload: Prisma.$SubscriptionPayload<ExtArgs>
      fields: Prisma.SubscriptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>
        }
        findFirst: {
          args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>
        }
        findMany: {
          args: Prisma.SubscriptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
        }
        create: {
          args: Prisma.SubscriptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>
        }
        createMany: {
          args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
        }
        delete: {
          args: Prisma.SubscriptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>
        }
        update: {
          args: Prisma.SubscriptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>
        }
        deleteMany: {
          args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
        }
        upsert: {
          args: Prisma.SubscriptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>
        }
        aggregate: {
          args: Prisma.SubscriptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSubscription>
        }
        groupBy: {
          args: Prisma.SubscriptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubscriptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.SubscriptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubscriptionCountAggregateOutputType> | number
        }
      }
    }
    Payment: {
      payload: Prisma.$PaymentPayload<ExtArgs>
      fields: Prisma.PaymentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        findFirst: {
          args: Prisma.PaymentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        findMany: {
          args: Prisma.PaymentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>[]
        }
        create: {
          args: Prisma.PaymentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        createMany: {
          args: Prisma.PaymentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>[]
        }
        delete: {
          args: Prisma.PaymentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        update: {
          args: Prisma.PaymentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        deleteMany: {
          args: Prisma.PaymentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>[]
        }
        upsert: {
          args: Prisma.PaymentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        aggregate: {
          args: Prisma.PaymentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayment>
        }
        groupBy: {
          args: Prisma.PaymentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentCountAggregateOutputType> | number
        }
      }
    }
    Patient: {
      payload: Prisma.$PatientPayload<ExtArgs>
      fields: Prisma.PatientFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PatientFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>
        }
        findFirst: {
          args: Prisma.PatientFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>
        }
        findMany: {
          args: Prisma.PatientFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>[]
        }
        create: {
          args: Prisma.PatientCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>
        }
        createMany: {
          args: Prisma.PatientCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>[]
        }
        delete: {
          args: Prisma.PatientDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>
        }
        update: {
          args: Prisma.PatientUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>
        }
        deleteMany: {
          args: Prisma.PatientDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PatientUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PatientUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>[]
        }
        upsert: {
          args: Prisma.PatientUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>
        }
        aggregate: {
          args: Prisma.PatientAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePatient>
        }
        groupBy: {
          args: Prisma.PatientGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PatientGroupByOutputType>[]
        }
        count: {
          args: Prisma.PatientCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PatientCountAggregateOutputType> | number
        }
      }
    }
    MedicalHistory: {
      payload: Prisma.$MedicalHistoryPayload<ExtArgs>
      fields: Prisma.MedicalHistoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MedicalHistoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalHistoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MedicalHistoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>
        }
        findFirst: {
          args: Prisma.MedicalHistoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalHistoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MedicalHistoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>
        }
        findMany: {
          args: Prisma.MedicalHistoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>[]
        }
        create: {
          args: Prisma.MedicalHistoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>
        }
        createMany: {
          args: Prisma.MedicalHistoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MedicalHistoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>[]
        }
        delete: {
          args: Prisma.MedicalHistoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>
        }
        update: {
          args: Prisma.MedicalHistoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>
        }
        deleteMany: {
          args: Prisma.MedicalHistoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MedicalHistoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MedicalHistoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>[]
        }
        upsert: {
          args: Prisma.MedicalHistoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>
        }
        aggregate: {
          args: Prisma.MedicalHistoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMedicalHistory>
        }
        groupBy: {
          args: Prisma.MedicalHistoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MedicalHistoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.MedicalHistoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MedicalHistoryCountAggregateOutputType> | number
        }
      }
    }
    FamilyHistory: {
      payload: Prisma.$FamilyHistoryPayload<ExtArgs>
      fields: Prisma.FamilyHistoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FamilyHistoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FamilyHistoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FamilyHistoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FamilyHistoryPayload>
        }
        findFirst: {
          args: Prisma.FamilyHistoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FamilyHistoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FamilyHistoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FamilyHistoryPayload>
        }
        findMany: {
          args: Prisma.FamilyHistoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FamilyHistoryPayload>[]
        }
        create: {
          args: Prisma.FamilyHistoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FamilyHistoryPayload>
        }
        createMany: {
          args: Prisma.FamilyHistoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FamilyHistoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FamilyHistoryPayload>[]
        }
        delete: {
          args: Prisma.FamilyHistoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FamilyHistoryPayload>
        }
        update: {
          args: Prisma.FamilyHistoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FamilyHistoryPayload>
        }
        deleteMany: {
          args: Prisma.FamilyHistoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FamilyHistoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FamilyHistoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FamilyHistoryPayload>[]
        }
        upsert: {
          args: Prisma.FamilyHistoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FamilyHistoryPayload>
        }
        aggregate: {
          args: Prisma.FamilyHistoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFamilyHistory>
        }
        groupBy: {
          args: Prisma.FamilyHistoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FamilyHistoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.FamilyHistoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FamilyHistoryCountAggregateOutputType> | number
        }
      }
    }
    Lifestyle: {
      payload: Prisma.$LifestylePayload<ExtArgs>
      fields: Prisma.LifestyleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LifestyleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LifestylePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LifestyleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LifestylePayload>
        }
        findFirst: {
          args: Prisma.LifestyleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LifestylePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LifestyleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LifestylePayload>
        }
        findMany: {
          args: Prisma.LifestyleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LifestylePayload>[]
        }
        create: {
          args: Prisma.LifestyleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LifestylePayload>
        }
        createMany: {
          args: Prisma.LifestyleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LifestyleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LifestylePayload>[]
        }
        delete: {
          args: Prisma.LifestyleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LifestylePayload>
        }
        update: {
          args: Prisma.LifestyleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LifestylePayload>
        }
        deleteMany: {
          args: Prisma.LifestyleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LifestyleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LifestyleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LifestylePayload>[]
        }
        upsert: {
          args: Prisma.LifestyleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LifestylePayload>
        }
        aggregate: {
          args: Prisma.LifestyleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLifestyle>
        }
        groupBy: {
          args: Prisma.LifestyleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LifestyleGroupByOutputType>[]
        }
        count: {
          args: Prisma.LifestyleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LifestyleCountAggregateOutputType> | number
        }
      }
    }
    Allergy: {
      payload: Prisma.$AllergyPayload<ExtArgs>
      fields: Prisma.AllergyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AllergyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AllergyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AllergyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AllergyPayload>
        }
        findFirst: {
          args: Prisma.AllergyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AllergyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AllergyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AllergyPayload>
        }
        findMany: {
          args: Prisma.AllergyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AllergyPayload>[]
        }
        create: {
          args: Prisma.AllergyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AllergyPayload>
        }
        createMany: {
          args: Prisma.AllergyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AllergyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AllergyPayload>[]
        }
        delete: {
          args: Prisma.AllergyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AllergyPayload>
        }
        update: {
          args: Prisma.AllergyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AllergyPayload>
        }
        deleteMany: {
          args: Prisma.AllergyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AllergyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AllergyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AllergyPayload>[]
        }
        upsert: {
          args: Prisma.AllergyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AllergyPayload>
        }
        aggregate: {
          args: Prisma.AllergyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAllergy>
        }
        groupBy: {
          args: Prisma.AllergyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AllergyGroupByOutputType>[]
        }
        count: {
          args: Prisma.AllergyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AllergyCountAggregateOutputType> | number
        }
      }
    }
    Doctor: {
      payload: Prisma.$DoctorPayload<ExtArgs>
      fields: Prisma.DoctorFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DoctorFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DoctorFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPayload>
        }
        findFirst: {
          args: Prisma.DoctorFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DoctorFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPayload>
        }
        findMany: {
          args: Prisma.DoctorFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPayload>[]
        }
        create: {
          args: Prisma.DoctorCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPayload>
        }
        createMany: {
          args: Prisma.DoctorCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DoctorCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPayload>[]
        }
        delete: {
          args: Prisma.DoctorDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPayload>
        }
        update: {
          args: Prisma.DoctorUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPayload>
        }
        deleteMany: {
          args: Prisma.DoctorDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DoctorUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DoctorUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPayload>[]
        }
        upsert: {
          args: Prisma.DoctorUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPayload>
        }
        aggregate: {
          args: Prisma.DoctorAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDoctor>
        }
        groupBy: {
          args: Prisma.DoctorGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DoctorGroupByOutputType>[]
        }
        count: {
          args: Prisma.DoctorCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DoctorCountAggregateOutputType> | number
        }
      }
    }
    PatientDoctor: {
      payload: Prisma.$PatientDoctorPayload<ExtArgs>
      fields: Prisma.PatientDoctorFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PatientDoctorFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientDoctorPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PatientDoctorFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientDoctorPayload>
        }
        findFirst: {
          args: Prisma.PatientDoctorFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientDoctorPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PatientDoctorFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientDoctorPayload>
        }
        findMany: {
          args: Prisma.PatientDoctorFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientDoctorPayload>[]
        }
        create: {
          args: Prisma.PatientDoctorCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientDoctorPayload>
        }
        createMany: {
          args: Prisma.PatientDoctorCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PatientDoctorCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientDoctorPayload>[]
        }
        delete: {
          args: Prisma.PatientDoctorDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientDoctorPayload>
        }
        update: {
          args: Prisma.PatientDoctorUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientDoctorPayload>
        }
        deleteMany: {
          args: Prisma.PatientDoctorDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PatientDoctorUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PatientDoctorUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientDoctorPayload>[]
        }
        upsert: {
          args: Prisma.PatientDoctorUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientDoctorPayload>
        }
        aggregate: {
          args: Prisma.PatientDoctorAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePatientDoctor>
        }
        groupBy: {
          args: Prisma.PatientDoctorGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PatientDoctorGroupByOutputType>[]
        }
        count: {
          args: Prisma.PatientDoctorCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PatientDoctorCountAggregateOutputType> | number
        }
      }
    }
    Consultation: {
      payload: Prisma.$ConsultationPayload<ExtArgs>
      fields: Prisma.ConsultationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConsultationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsultationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConsultationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsultationPayload>
        }
        findFirst: {
          args: Prisma.ConsultationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsultationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConsultationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsultationPayload>
        }
        findMany: {
          args: Prisma.ConsultationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsultationPayload>[]
        }
        create: {
          args: Prisma.ConsultationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsultationPayload>
        }
        createMany: {
          args: Prisma.ConsultationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConsultationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsultationPayload>[]
        }
        delete: {
          args: Prisma.ConsultationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsultationPayload>
        }
        update: {
          args: Prisma.ConsultationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsultationPayload>
        }
        deleteMany: {
          args: Prisma.ConsultationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConsultationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConsultationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsultationPayload>[]
        }
        upsert: {
          args: Prisma.ConsultationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsultationPayload>
        }
        aggregate: {
          args: Prisma.ConsultationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConsultation>
        }
        groupBy: {
          args: Prisma.ConsultationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConsultationGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConsultationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConsultationCountAggregateOutputType> | number
        }
      }
    }
    Appointment: {
      payload: Prisma.$AppointmentPayload<ExtArgs>
      fields: Prisma.AppointmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>
        }
        findFirst: {
          args: Prisma.AppointmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>
        }
        findMany: {
          args: Prisma.AppointmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
        }
        create: {
          args: Prisma.AppointmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>
        }
        createMany: {
          args: Prisma.AppointmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
        }
        delete: {
          args: Prisma.AppointmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>
        }
        update: {
          args: Prisma.AppointmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>
        }
        deleteMany: {
          args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AppointmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
        }
        upsert: {
          args: Prisma.AppointmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>
        }
        aggregate: {
          args: Prisma.AppointmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAppointment>
        }
        groupBy: {
          args: Prisma.AppointmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AppointmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.AppointmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AppointmentCountAggregateOutputType> | number
        }
      }
    }
    Disease: {
      payload: Prisma.$DiseasePayload<ExtArgs>
      fields: Prisma.DiseaseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DiseaseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiseasePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DiseaseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiseasePayload>
        }
        findFirst: {
          args: Prisma.DiseaseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiseasePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DiseaseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiseasePayload>
        }
        findMany: {
          args: Prisma.DiseaseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiseasePayload>[]
        }
        create: {
          args: Prisma.DiseaseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiseasePayload>
        }
        createMany: {
          args: Prisma.DiseaseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DiseaseCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiseasePayload>[]
        }
        delete: {
          args: Prisma.DiseaseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiseasePayload>
        }
        update: {
          args: Prisma.DiseaseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiseasePayload>
        }
        deleteMany: {
          args: Prisma.DiseaseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DiseaseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DiseaseUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiseasePayload>[]
        }
        upsert: {
          args: Prisma.DiseaseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiseasePayload>
        }
        aggregate: {
          args: Prisma.DiseaseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDisease>
        }
        groupBy: {
          args: Prisma.DiseaseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DiseaseGroupByOutputType>[]
        }
        count: {
          args: Prisma.DiseaseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DiseaseCountAggregateOutputType> | number
        }
      }
    }
    PatientDisease: {
      payload: Prisma.$PatientDiseasePayload<ExtArgs>
      fields: Prisma.PatientDiseaseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PatientDiseaseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientDiseasePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PatientDiseaseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientDiseasePayload>
        }
        findFirst: {
          args: Prisma.PatientDiseaseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientDiseasePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PatientDiseaseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientDiseasePayload>
        }
        findMany: {
          args: Prisma.PatientDiseaseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientDiseasePayload>[]
        }
        create: {
          args: Prisma.PatientDiseaseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientDiseasePayload>
        }
        createMany: {
          args: Prisma.PatientDiseaseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PatientDiseaseCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientDiseasePayload>[]
        }
        delete: {
          args: Prisma.PatientDiseaseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientDiseasePayload>
        }
        update: {
          args: Prisma.PatientDiseaseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientDiseasePayload>
        }
        deleteMany: {
          args: Prisma.PatientDiseaseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PatientDiseaseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PatientDiseaseUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientDiseasePayload>[]
        }
        upsert: {
          args: Prisma.PatientDiseaseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientDiseasePayload>
        }
        aggregate: {
          args: Prisma.PatientDiseaseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePatientDisease>
        }
        groupBy: {
          args: Prisma.PatientDiseaseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PatientDiseaseGroupByOutputType>[]
        }
        count: {
          args: Prisma.PatientDiseaseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PatientDiseaseCountAggregateOutputType> | number
        }
      }
    }
    ActiveSubstance: {
      payload: Prisma.$ActiveSubstancePayload<ExtArgs>
      fields: Prisma.ActiveSubstanceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ActiveSubstanceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActiveSubstancePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ActiveSubstanceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActiveSubstancePayload>
        }
        findFirst: {
          args: Prisma.ActiveSubstanceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActiveSubstancePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ActiveSubstanceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActiveSubstancePayload>
        }
        findMany: {
          args: Prisma.ActiveSubstanceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActiveSubstancePayload>[]
        }
        create: {
          args: Prisma.ActiveSubstanceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActiveSubstancePayload>
        }
        createMany: {
          args: Prisma.ActiveSubstanceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ActiveSubstanceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActiveSubstancePayload>[]
        }
        delete: {
          args: Prisma.ActiveSubstanceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActiveSubstancePayload>
        }
        update: {
          args: Prisma.ActiveSubstanceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActiveSubstancePayload>
        }
        deleteMany: {
          args: Prisma.ActiveSubstanceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ActiveSubstanceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ActiveSubstanceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActiveSubstancePayload>[]
        }
        upsert: {
          args: Prisma.ActiveSubstanceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActiveSubstancePayload>
        }
        aggregate: {
          args: Prisma.ActiveSubstanceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateActiveSubstance>
        }
        groupBy: {
          args: Prisma.ActiveSubstanceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ActiveSubstanceGroupByOutputType>[]
        }
        count: {
          args: Prisma.ActiveSubstanceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ActiveSubstanceCountAggregateOutputType> | number
        }
      }
    }
    DiseaseActiveSubstanceWarning: {
      payload: Prisma.$DiseaseActiveSubstanceWarningPayload<ExtArgs>
      fields: Prisma.DiseaseActiveSubstanceWarningFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DiseaseActiveSubstanceWarningFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiseaseActiveSubstanceWarningPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DiseaseActiveSubstanceWarningFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiseaseActiveSubstanceWarningPayload>
        }
        findFirst: {
          args: Prisma.DiseaseActiveSubstanceWarningFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiseaseActiveSubstanceWarningPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DiseaseActiveSubstanceWarningFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiseaseActiveSubstanceWarningPayload>
        }
        findMany: {
          args: Prisma.DiseaseActiveSubstanceWarningFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiseaseActiveSubstanceWarningPayload>[]
        }
        create: {
          args: Prisma.DiseaseActiveSubstanceWarningCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiseaseActiveSubstanceWarningPayload>
        }
        createMany: {
          args: Prisma.DiseaseActiveSubstanceWarningCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DiseaseActiveSubstanceWarningCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiseaseActiveSubstanceWarningPayload>[]
        }
        delete: {
          args: Prisma.DiseaseActiveSubstanceWarningDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiseaseActiveSubstanceWarningPayload>
        }
        update: {
          args: Prisma.DiseaseActiveSubstanceWarningUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiseaseActiveSubstanceWarningPayload>
        }
        deleteMany: {
          args: Prisma.DiseaseActiveSubstanceWarningDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DiseaseActiveSubstanceWarningUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DiseaseActiveSubstanceWarningUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiseaseActiveSubstanceWarningPayload>[]
        }
        upsert: {
          args: Prisma.DiseaseActiveSubstanceWarningUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiseaseActiveSubstanceWarningPayload>
        }
        aggregate: {
          args: Prisma.DiseaseActiveSubstanceWarningAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDiseaseActiveSubstanceWarning>
        }
        groupBy: {
          args: Prisma.DiseaseActiveSubstanceWarningGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DiseaseActiveSubstanceWarningGroupByOutputType>[]
        }
        count: {
          args: Prisma.DiseaseActiveSubstanceWarningCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DiseaseActiveSubstanceWarningCountAggregateOutputType> | number
        }
      }
    }
    MedicineAlternative: {
      payload: Prisma.$MedicineAlternativePayload<ExtArgs>
      fields: Prisma.MedicineAlternativeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MedicineAlternativeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicineAlternativePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MedicineAlternativeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicineAlternativePayload>
        }
        findFirst: {
          args: Prisma.MedicineAlternativeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicineAlternativePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MedicineAlternativeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicineAlternativePayload>
        }
        findMany: {
          args: Prisma.MedicineAlternativeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicineAlternativePayload>[]
        }
        create: {
          args: Prisma.MedicineAlternativeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicineAlternativePayload>
        }
        createMany: {
          args: Prisma.MedicineAlternativeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MedicineAlternativeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicineAlternativePayload>[]
        }
        delete: {
          args: Prisma.MedicineAlternativeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicineAlternativePayload>
        }
        update: {
          args: Prisma.MedicineAlternativeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicineAlternativePayload>
        }
        deleteMany: {
          args: Prisma.MedicineAlternativeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MedicineAlternativeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MedicineAlternativeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicineAlternativePayload>[]
        }
        upsert: {
          args: Prisma.MedicineAlternativeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicineAlternativePayload>
        }
        aggregate: {
          args: Prisma.MedicineAlternativeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMedicineAlternative>
        }
        groupBy: {
          args: Prisma.MedicineAlternativeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MedicineAlternativeGroupByOutputType>[]
        }
        count: {
          args: Prisma.MedicineAlternativeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MedicineAlternativeCountAggregateOutputType> | number
        }
      }
    }
    TradeName: {
      payload: Prisma.$TradeNamePayload<ExtArgs>
      fields: Prisma.TradeNameFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TradeNameFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TradeNamePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TradeNameFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TradeNamePayload>
        }
        findFirst: {
          args: Prisma.TradeNameFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TradeNamePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TradeNameFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TradeNamePayload>
        }
        findMany: {
          args: Prisma.TradeNameFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TradeNamePayload>[]
        }
        create: {
          args: Prisma.TradeNameCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TradeNamePayload>
        }
        createMany: {
          args: Prisma.TradeNameCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TradeNameCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TradeNamePayload>[]
        }
        delete: {
          args: Prisma.TradeNameDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TradeNamePayload>
        }
        update: {
          args: Prisma.TradeNameUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TradeNamePayload>
        }
        deleteMany: {
          args: Prisma.TradeNameDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TradeNameUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TradeNameUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TradeNamePayload>[]
        }
        upsert: {
          args: Prisma.TradeNameUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TradeNamePayload>
        }
        aggregate: {
          args: Prisma.TradeNameAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTradeName>
        }
        groupBy: {
          args: Prisma.TradeNameGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TradeNameGroupByOutputType>[]
        }
        count: {
          args: Prisma.TradeNameCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TradeNameCountAggregateOutputType> | number
        }
      }
    }
    Company: {
      payload: Prisma.$CompanyPayload<ExtArgs>
      fields: Prisma.CompanyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CompanyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        findFirst: {
          args: Prisma.CompanyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        findMany: {
          args: Prisma.CompanyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>[]
        }
        create: {
          args: Prisma.CompanyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        createMany: {
          args: Prisma.CompanyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>[]
        }
        delete: {
          args: Prisma.CompanyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        update: {
          args: Prisma.CompanyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        deleteMany: {
          args: Prisma.CompanyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CompanyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>[]
        }
        upsert: {
          args: Prisma.CompanyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        aggregate: {
          args: Prisma.CompanyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCompany>
        }
        groupBy: {
          args: Prisma.CompanyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyGroupByOutputType>[]
        }
        count: {
          args: Prisma.CompanyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyCountAggregateOutputType> | number
        }
      }
    }
    ContractingCompany: {
      payload: Prisma.$ContractingCompanyPayload<ExtArgs>
      fields: Prisma.ContractingCompanyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ContractingCompanyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContractingCompanyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ContractingCompanyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContractingCompanyPayload>
        }
        findFirst: {
          args: Prisma.ContractingCompanyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContractingCompanyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ContractingCompanyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContractingCompanyPayload>
        }
        findMany: {
          args: Prisma.ContractingCompanyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContractingCompanyPayload>[]
        }
        create: {
          args: Prisma.ContractingCompanyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContractingCompanyPayload>
        }
        createMany: {
          args: Prisma.ContractingCompanyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ContractingCompanyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContractingCompanyPayload>[]
        }
        delete: {
          args: Prisma.ContractingCompanyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContractingCompanyPayload>
        }
        update: {
          args: Prisma.ContractingCompanyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContractingCompanyPayload>
        }
        deleteMany: {
          args: Prisma.ContractingCompanyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ContractingCompanyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ContractingCompanyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContractingCompanyPayload>[]
        }
        upsert: {
          args: Prisma.ContractingCompanyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContractingCompanyPayload>
        }
        aggregate: {
          args: Prisma.ContractingCompanyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateContractingCompany>
        }
        groupBy: {
          args: Prisma.ContractingCompanyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ContractingCompanyGroupByOutputType>[]
        }
        count: {
          args: Prisma.ContractingCompanyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ContractingCompanyCountAggregateOutputType> | number
        }
      }
    }
    ContractingCompanyTradeName: {
      payload: Prisma.$ContractingCompanyTradeNamePayload<ExtArgs>
      fields: Prisma.ContractingCompanyTradeNameFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ContractingCompanyTradeNameFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContractingCompanyTradeNamePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ContractingCompanyTradeNameFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContractingCompanyTradeNamePayload>
        }
        findFirst: {
          args: Prisma.ContractingCompanyTradeNameFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContractingCompanyTradeNamePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ContractingCompanyTradeNameFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContractingCompanyTradeNamePayload>
        }
        findMany: {
          args: Prisma.ContractingCompanyTradeNameFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContractingCompanyTradeNamePayload>[]
        }
        create: {
          args: Prisma.ContractingCompanyTradeNameCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContractingCompanyTradeNamePayload>
        }
        createMany: {
          args: Prisma.ContractingCompanyTradeNameCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ContractingCompanyTradeNameCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContractingCompanyTradeNamePayload>[]
        }
        delete: {
          args: Prisma.ContractingCompanyTradeNameDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContractingCompanyTradeNamePayload>
        }
        update: {
          args: Prisma.ContractingCompanyTradeNameUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContractingCompanyTradeNamePayload>
        }
        deleteMany: {
          args: Prisma.ContractingCompanyTradeNameDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ContractingCompanyTradeNameUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ContractingCompanyTradeNameUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContractingCompanyTradeNamePayload>[]
        }
        upsert: {
          args: Prisma.ContractingCompanyTradeNameUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContractingCompanyTradeNamePayload>
        }
        aggregate: {
          args: Prisma.ContractingCompanyTradeNameAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateContractingCompanyTradeName>
        }
        groupBy: {
          args: Prisma.ContractingCompanyTradeNameGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ContractingCompanyTradeNameGroupByOutputType>[]
        }
        count: {
          args: Prisma.ContractingCompanyTradeNameCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ContractingCompanyTradeNameCountAggregateOutputType> | number
        }
      }
    }
    Prescription: {
      payload: Prisma.$PrescriptionPayload<ExtArgs>
      fields: Prisma.PrescriptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PrescriptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PrescriptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>
        }
        findFirst: {
          args: Prisma.PrescriptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PrescriptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>
        }
        findMany: {
          args: Prisma.PrescriptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
        }
        create: {
          args: Prisma.PrescriptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>
        }
        createMany: {
          args: Prisma.PrescriptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PrescriptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
        }
        delete: {
          args: Prisma.PrescriptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>
        }
        update: {
          args: Prisma.PrescriptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>
        }
        deleteMany: {
          args: Prisma.PrescriptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PrescriptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PrescriptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
        }
        upsert: {
          args: Prisma.PrescriptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>
        }
        aggregate: {
          args: Prisma.PrescriptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePrescription>
        }
        groupBy: {
          args: Prisma.PrescriptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PrescriptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.PrescriptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PrescriptionCountAggregateOutputType> | number
        }
      }
    }
    PrescriptionVersion: {
      payload: Prisma.$PrescriptionVersionPayload<ExtArgs>
      fields: Prisma.PrescriptionVersionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PrescriptionVersionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionVersionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PrescriptionVersionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionVersionPayload>
        }
        findFirst: {
          args: Prisma.PrescriptionVersionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionVersionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PrescriptionVersionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionVersionPayload>
        }
        findMany: {
          args: Prisma.PrescriptionVersionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionVersionPayload>[]
        }
        create: {
          args: Prisma.PrescriptionVersionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionVersionPayload>
        }
        createMany: {
          args: Prisma.PrescriptionVersionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PrescriptionVersionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionVersionPayload>[]
        }
        delete: {
          args: Prisma.PrescriptionVersionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionVersionPayload>
        }
        update: {
          args: Prisma.PrescriptionVersionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionVersionPayload>
        }
        deleteMany: {
          args: Prisma.PrescriptionVersionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PrescriptionVersionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PrescriptionVersionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionVersionPayload>[]
        }
        upsert: {
          args: Prisma.PrescriptionVersionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionVersionPayload>
        }
        aggregate: {
          args: Prisma.PrescriptionVersionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePrescriptionVersion>
        }
        groupBy: {
          args: Prisma.PrescriptionVersionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PrescriptionVersionGroupByOutputType>[]
        }
        count: {
          args: Prisma.PrescriptionVersionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PrescriptionVersionCountAggregateOutputType> | number
        }
      }
    }
    DrugInteractionAlert: {
      payload: Prisma.$DrugInteractionAlertPayload<ExtArgs>
      fields: Prisma.DrugInteractionAlertFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DrugInteractionAlertFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DrugInteractionAlertPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DrugInteractionAlertFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DrugInteractionAlertPayload>
        }
        findFirst: {
          args: Prisma.DrugInteractionAlertFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DrugInteractionAlertPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DrugInteractionAlertFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DrugInteractionAlertPayload>
        }
        findMany: {
          args: Prisma.DrugInteractionAlertFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DrugInteractionAlertPayload>[]
        }
        create: {
          args: Prisma.DrugInteractionAlertCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DrugInteractionAlertPayload>
        }
        createMany: {
          args: Prisma.DrugInteractionAlertCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DrugInteractionAlertCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DrugInteractionAlertPayload>[]
        }
        delete: {
          args: Prisma.DrugInteractionAlertDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DrugInteractionAlertPayload>
        }
        update: {
          args: Prisma.DrugInteractionAlertUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DrugInteractionAlertPayload>
        }
        deleteMany: {
          args: Prisma.DrugInteractionAlertDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DrugInteractionAlertUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DrugInteractionAlertUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DrugInteractionAlertPayload>[]
        }
        upsert: {
          args: Prisma.DrugInteractionAlertUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DrugInteractionAlertPayload>
        }
        aggregate: {
          args: Prisma.DrugInteractionAlertAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDrugInteractionAlert>
        }
        groupBy: {
          args: Prisma.DrugInteractionAlertGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DrugInteractionAlertGroupByOutputType>[]
        }
        count: {
          args: Prisma.DrugInteractionAlertCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DrugInteractionAlertCountAggregateOutputType> | number
        }
      }
    }
    Notification: {
      payload: Prisma.$NotificationPayload<ExtArgs>
      fields: Prisma.NotificationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NotificationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        findFirst: {
          args: Prisma.NotificationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        findMany: {
          args: Prisma.NotificationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        create: {
          args: Prisma.NotificationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        createMany: {
          args: Prisma.NotificationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        delete: {
          args: Prisma.NotificationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        update: {
          args: Prisma.NotificationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        deleteMany: {
          args: Prisma.NotificationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NotificationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        upsert: {
          args: Prisma.NotificationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        aggregate: {
          args: Prisma.NotificationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotification>
        }
        groupBy: {
          args: Prisma.NotificationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationGroupByOutputType>[]
        }
        count: {
          args: Prisma.NotificationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationCountAggregateOutputType> | number
        }
      }
    }
    AuditLog: {
      payload: Prisma.$AuditLogPayload<ExtArgs>
      fields: Prisma.AuditLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        findFirst: {
          args: Prisma.AuditLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        findMany: {
          args: Prisma.AuditLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        create: {
          args: Prisma.AuditLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        createMany: {
          args: Prisma.AuditLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        delete: {
          args: Prisma.AuditLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        update: {
          args: Prisma.AuditLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        deleteMany: {
          args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        upsert: {
          args: Prisma.AuditLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        aggregate: {
          args: Prisma.AuditLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAuditLog>
        }
        groupBy: {
          args: Prisma.AuditLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.AuditLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditLogCountAggregateOutputType> | number
        }
      }
    }
    Session: {
      payload: Prisma.$SessionPayload<ExtArgs>
      fields: Prisma.SessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        findFirst: {
          args: Prisma.SessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        findMany: {
          args: Prisma.SessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        create: {
          args: Prisma.SessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        createMany: {
          args: Prisma.SessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        delete: {
          args: Prisma.SessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        update: {
          args: Prisma.SessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        deleteMany: {
          args: Prisma.SessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        upsert: {
          args: Prisma.SessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        aggregate: {
          args: Prisma.SessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSession>
        }
        groupBy: {
          args: Prisma.SessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.SessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const UserScalarFieldEnum = {
  id: 'id',
  email: 'email',
  passwordHash: 'passwordHash',
  role: 'role',
  emailVerified: 'emailVerified',
  emailVerificationToken: 'emailVerificationToken',
  passwordResetToken: 'passwordResetToken',
  passwordResetExpires: 'passwordResetExpires',
  isActive: 'isActive',
  lastLoginAt: 'lastLoginAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const PricingPlanScalarFieldEnum = {
  id: 'id',
  title: 'title',
  price: 'price',
  salePrice: 'salePrice',
  duration: 'duration',
  isDefault: 'isDefault',
  features: 'features',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PricingPlanScalarFieldEnum = (typeof PricingPlanScalarFieldEnum)[keyof typeof PricingPlanScalarFieldEnum]


export const SubscriptionScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  pricingPlanId: 'pricingPlanId',
  status: 'status',
  startDate: 'startDate',
  endDate: 'endDate',
  autoRenew: 'autoRenew',
  cancelledAt: 'cancelledAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


export const PaymentScalarFieldEnum = {
  id: 'id',
  subscriptionId: 'subscriptionId',
  amount: 'amount',
  currency: 'currency',
  paymentMethod: 'paymentMethod',
  transactionId: 'transactionId',
  status: 'status',
  paidAt: 'paidAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


export const PatientScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  name: 'name',
  age: 'age',
  ageClassification: 'ageClassification',
  weight: 'weight',
  height: 'height',
  gender: 'gender',
  smoking: 'smoking',
  pregnancyWarning: 'pregnancyWarning',
  lactation: 'lactation',
  profileCompleteness: 'profileCompleteness',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


export const MedicalHistoryScalarFieldEnum = {
  id: 'id',
  patientId: 'patientId',
  condition: 'condition',
  diagnosisDate: 'diagnosisDate',
  treatment: 'treatment',
  status: 'status',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MedicalHistoryScalarFieldEnum = (typeof MedicalHistoryScalarFieldEnum)[keyof typeof MedicalHistoryScalarFieldEnum]


export const FamilyHistoryScalarFieldEnum = {
  id: 'id',
  patientId: 'patientId',
  relation: 'relation',
  condition: 'condition',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FamilyHistoryScalarFieldEnum = (typeof FamilyHistoryScalarFieldEnum)[keyof typeof FamilyHistoryScalarFieldEnum]


export const LifestyleScalarFieldEnum = {
  id: 'id',
  patientId: 'patientId',
  noGlasses: 'noGlasses',
  alcoholAbuse: 'alcoholAbuse',
  excessCaffeine: 'excessCaffeine',
  waterDaily: 'waterDaily',
  travellerAbroad: 'travellerAbroad',
  annualVaccination: 'annualVaccination',
  surgeriesLast3Months: 'surgeriesLast3Months',
  surgeriesDetails: 'surgeriesDetails',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LifestyleScalarFieldEnum = (typeof LifestyleScalarFieldEnum)[keyof typeof LifestyleScalarFieldEnum]


export const AllergyScalarFieldEnum = {
  id: 'id',
  patientId: 'patientId',
  allergen: 'allergen',
  severity: 'severity',
  reactionType: 'reactionType',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AllergyScalarFieldEnum = (typeof AllergyScalarFieldEnum)[keyof typeof AllergyScalarFieldEnum]


export const DoctorScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  name: 'name',
  licenseNumber: 'licenseNumber',
  specialization: 'specialization',
  isVerified: 'isVerified',
  verifiedAt: 'verifiedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type DoctorScalarFieldEnum = (typeof DoctorScalarFieldEnum)[keyof typeof DoctorScalarFieldEnum]


export const PatientDoctorScalarFieldEnum = {
  id: 'id',
  patientId: 'patientId',
  doctorId: 'doctorId',
  relationshipType: 'relationshipType',
  startDate: 'startDate',
  endDate: 'endDate',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PatientDoctorScalarFieldEnum = (typeof PatientDoctorScalarFieldEnum)[keyof typeof PatientDoctorScalarFieldEnum]


export const ConsultationScalarFieldEnum = {
  id: 'id',
  patientId: 'patientId',
  doctorId: 'doctorId',
  consultationDate: 'consultationDate',
  notes: 'notes',
  diagnosis: 'diagnosis',
  followUpRequired: 'followUpRequired',
  followUpDate: 'followUpDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConsultationScalarFieldEnum = (typeof ConsultationScalarFieldEnum)[keyof typeof ConsultationScalarFieldEnum]


export const AppointmentScalarFieldEnum = {
  id: 'id',
  patientId: 'patientId',
  doctorId: 'doctorId',
  appointmentDate: 'appointmentDate',
  duration: 'duration',
  status: 'status',
  notes: 'notes',
  reminderSent: 'reminderSent',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


export const DiseaseScalarFieldEnum = {
  id: 'id',
  name: 'name',
  severity: 'severity',
  description: 'description',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DiseaseScalarFieldEnum = (typeof DiseaseScalarFieldEnum)[keyof typeof DiseaseScalarFieldEnum]


export const PatientDiseaseScalarFieldEnum = {
  id: 'id',
  patientId: 'patientId',
  diseaseId: 'diseaseId',
  diagnosisDate: 'diagnosisDate',
  severity: 'severity',
  status: 'status',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PatientDiseaseScalarFieldEnum = (typeof PatientDiseaseScalarFieldEnum)[keyof typeof PatientDiseaseScalarFieldEnum]


export const ActiveSubstanceScalarFieldEnum = {
  id: 'id',
  activeSubstance: 'activeSubstance',
  concentration: 'concentration',
  classification: 'classification',
  dosageForm: 'dosageForm',
  indication: 'indication',
  adultDoseMaxPerDay: 'adultDoseMaxPerDay',
  adultDoseMgPerKg: 'adultDoseMgPerKg',
  doseInKg: 'doseInKg',
  pediatricDose: 'pediatricDose',
  glucoseContent: 'glucoseContent',
  lactoseContent: 'lactoseContent',
  fructoseContent: 'fructoseContent',
  preservativesInOcularProducts: 'preservativesInOcularProducts',
  eliminationPathway: 'eliminationPathway',
  contraindications: 'contraindications',
  pregnancyWarning: 'pregnancyWarning',
  lactationWarning: 'lactationWarning',
  reproductiveWarningFemale: 'reproductiveWarningFemale',
  reproductiveWarningMale: 'reproductiveWarningMale',
  specialPopulationChildren: 'specialPopulationChildren',
  specialPopulationElderly: 'specialPopulationElderly',
  ethnicAction: 'ethnicAction',
  hepaticWarning: 'hepaticWarning',
  renalWarning: 'renalWarning',
  medicationErrorWarning: 'medicationErrorWarning',
  carcinogenicityMutagenicity: 'carcinogenicityMutagenicity',
  gitWarning: 'gitWarning',
  metabolismWarning: 'metabolismWarning',
  pulmonaryWarning: 'pulmonaryWarning',
  immuneSystemWarning: 'immuneSystemWarning',
  infectionWarning: 'infectionWarning',
  bloodWarning: 'bloodWarning',
  vascularWarning: 'vascularWarning',
  electrolyteImbalanceWarning: 'electrolyteImbalanceWarning',
  cardiacWarning: 'cardiacWarning',
  psychiatricWarning: 'psychiatricWarning',
  nervousSystemWarning: 'nervousSystemWarning',
  skinConnectiveTissueWarning: 'skinConnectiveTissueWarning',
  musculoSkeletalWarning: 'musculoSkeletalWarning',
  eyeDisordersWarning: 'eyeDisordersWarning',
  earDisordersWarning: 'earDisordersWarning',
  interactionVitaminsFood: 'interactionVitaminsFood',
  interactionBisphosphonates: 'interactionBisphosphonates',
  interactionAlcohol: 'interactionAlcohol',
  interactionMuscleRelaxant: 'interactionMuscleRelaxant',
  interactionRetinoids: 'interactionRetinoids',
  interactionCorticosteroids: 'interactionCorticosteroids',
  interactionXanthines: 'interactionXanthines',
  interactionSympathomimetics: 'interactionSympathomimetics',
  interactionAnticholinergic: 'interactionAnticholinergic',
  interactionChemotherapy: 'interactionChemotherapy',
  interactionAntibiotics: 'interactionAntibiotics',
  interactionHormones: 'interactionHormones',
  interactionStatins: 'interactionStatins',
  interactionAntihypertensive: 'interactionAntihypertensive',
  interactionAntidiuretics: 'interactionAntidiuretics',
  interactionAntidepressant: 'interactionAntidepressant',
  interactionAntidiabetic: 'interactionAntidiabetic',
  interactionLowBloodSugarAgents: 'interactionLowBloodSugarAgents',
  interactionDigoxin: 'interactionDigoxin',
  interactionAnticoagulant: 'interactionAnticoagulant',
  interactionNSAIDs: 'interactionNSAIDs',
  interactionImmunosuppressive: 'interactionImmunosuppressive',
  interactionAntacids: 'interactionAntacids',
  interactionUricosurics: 'interactionUricosurics',
  interactionProtectants: 'interactionProtectants',
  interactionAntiParkinson: 'interactionAntiParkinson',
  interactionHIVProtease: 'interactionHIVProtease',
  ironChelator: 'ironChelator',
  interactionBloodProduct: 'interactionBloodProduct',
  interactionVaccines: 'interactionVaccines',
  interactionAnthelmintics: 'interactionAnthelmintics',
  interactionPDE5Inhibitors: 'interactionPDE5Inhibitors',
  interferenceLabTests: 'interferenceLabTests',
  effectOnDriving: 'effectOnDriving',
  veryCommonGIT: 'veryCommonGIT',
  veryCommonBlood: 'veryCommonBlood',
  veryCommonVascular: 'veryCommonVascular',
  veryCommonCardiac: 'veryCommonCardiac',
  veryCommonMusculoskeletal: 'veryCommonMusculoskeletal',
  veryCommonNervousSystem: 'veryCommonNervousSystem',
  veryCommonEye: 'veryCommonEye',
  veryCommonMetabolism: 'veryCommonMetabolism',
  veryCommonEar: 'veryCommonEar',
  veryCommonRespiratory: 'veryCommonRespiratory',
  veryCommonSkin: 'veryCommonSkin',
  veryCommonInfection: 'veryCommonInfection',
  veryCommonPsychiatric: 'veryCommonPsychiatric',
  veryCommonRenal: 'veryCommonRenal',
  veryCommonHepatic: 'veryCommonHepatic',
  veryCommonGeneral: 'veryCommonGeneral',
  commonGIT: 'commonGIT',
  commonVascular: 'commonVascular',
  commonInfections: 'commonInfections',
  commonRespiratory: 'commonRespiratory',
  commonCardiac: 'commonCardiac',
  commonBlood: 'commonBlood',
  commonSkin: 'commonSkin',
  commonEye: 'commonEye',
  commonEar: 'commonEar',
  commonMetabolism: 'commonMetabolism',
  commonGeneral: 'commonGeneral',
  commonHepatobiliary: 'commonHepatobiliary',
  commonImmunity: 'commonImmunity',
  commonPsychiatric: 'commonPsychiatric',
  commonNervousSystem: 'commonNervousSystem',
  commonRenal: 'commonRenal',
  commonMusculoskeletal: 'commonMusculoskeletal',
  uncommonNervous: 'uncommonNervous',
  uncommonInfections: 'uncommonInfections',
  uncommonPsychiatric: 'uncommonPsychiatric',
  uncommonEye: 'uncommonEye',
  uncommonRespiratory: 'uncommonRespiratory',
  uncommonSkin: 'uncommonSkin',
  uncommonRenal: 'uncommonRenal',
  uncommonHepatobiliary: 'uncommonHepatobiliary',
  uncommonVascular: 'uncommonVascular',
  uncommonGIT: 'uncommonGIT',
  uncommonMusculoskeletal: 'uncommonMusculoskeletal',
  uncommonMetabolism: 'uncommonMetabolism',
  uncommonEar: 'uncommonEar',
  uncommonCardiac: 'uncommonCardiac',
  uncommonBlood: 'uncommonBlood',
  uncommonImmunity: 'uncommonImmunity',
  uncommonGeneral: 'uncommonGeneral',
  rareEar: 'rareEar',
  rareBlood: 'rareBlood',
  rareGIT: 'rareGIT',
  rareHepatic: 'rareHepatic',
  rareInfections: 'rareInfections',
  rareCardiac: 'rareCardiac',
  rareVascular: 'rareVascular',
  rareImmune: 'rareImmune',
  rareMetabolism: 'rareMetabolism',
  rareNervous: 'rareNervous',
  rareMusculoskeletal: 'rareMusculoskeletal',
  rarePsychiatric: 'rarePsychiatric',
  rareEye: 'rareEye',
  rareRenal: 'rareRenal',
  rareSkin: 'rareSkin',
  rareRespiratory: 'rareRespiratory',
  rareEndocrine: 'rareEndocrine',
  rareGeneral: 'rareGeneral',
  veryRareVascular: 'veryRareVascular',
  veryRareEndocrine: 'veryRareEndocrine',
  veryRareNervous: 'veryRareNervous',
  veryRarePsychiatric: 'veryRarePsychiatric',
  veryRareEye: 'veryRareEye',
  veryRareMusculoskeletal: 'veryRareMusculoskeletal',
  veryRareBlood: 'veryRareBlood',
  veryRareCardiac: 'veryRareCardiac',
  veryRareImmune: 'veryRareImmune',
  veryRareEar: 'veryRareEar',
  veryRareRenal: 'veryRareRenal',
  veryRareGIT: 'veryRareGIT',
  veryRareHepatobiliary: 'veryRareHepatobiliary',
  veryRareInfections: 'veryRareInfections',
  veryRareRespiratory: 'veryRareRespiratory',
  veryRareSkin: 'veryRareSkin',
  veryRareGeneral: 'veryRareGeneral',
  veryRareMetabolism: 'veryRareMetabolism',
  unknownNervous: 'unknownNervous',
  unknownMusculoskeletal: 'unknownMusculoskeletal',
  unknownPsychiatric: 'unknownPsychiatric',
  unknownHepatobiliary: 'unknownHepatobiliary',
  unknownRenal: 'unknownRenal',
  unknownSkin: 'unknownSkin',
  unknownRespiratory: 'unknownRespiratory',
  unknownImmune: 'unknownImmune',
  unknownVascular: 'unknownVascular',
  unknownEar: 'unknownEar',
  unknownGIT: 'unknownGIT',
  unknownGeneral: 'unknownGeneral',
  unknownMetabolism: 'unknownMetabolism',
  unknownEye: 'unknownEye',
  unknownBlood: 'unknownBlood',
  unknownCardiac: 'unknownCardiac',
  unknownInfections: 'unknownInfections',
  unknownEndocrine: 'unknownEndocrine',
  additiveRMM: 'additiveRMM',
  pregnancyCategory: 'pregnancyCategory',
  additionalMonitoring: 'additionalMonitoring',
  highlightedWarning: 'highlightedWarning',
  version: 'version',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type ActiveSubstanceScalarFieldEnum = (typeof ActiveSubstanceScalarFieldEnum)[keyof typeof ActiveSubstanceScalarFieldEnum]


export const DiseaseActiveSubstanceWarningScalarFieldEnum = {
  id: 'id',
  diseaseId: 'diseaseId',
  activeSubstanceId: 'activeSubstanceId',
  warningFieldName: 'warningFieldName',
  warningMessage: 'warningMessage',
  severity: 'severity',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DiseaseActiveSubstanceWarningScalarFieldEnum = (typeof DiseaseActiveSubstanceWarningScalarFieldEnum)[keyof typeof DiseaseActiveSubstanceWarningScalarFieldEnum]


export const MedicineAlternativeScalarFieldEnum = {
  id: 'id',
  activeSubstanceId: 'activeSubstanceId',
  alternativeActiveSubstanceId: 'alternativeActiveSubstanceId',
  reason: 'reason',
  createdAt: 'createdAt'
} as const

export type MedicineAlternativeScalarFieldEnum = (typeof MedicineAlternativeScalarFieldEnum)[keyof typeof MedicineAlternativeScalarFieldEnum]


export const TradeNameScalarFieldEnum = {
  id: 'id',
  title: 'title',
  activeSubstanceId: 'activeSubstanceId',
  companyId: 'companyId',
  warningNotification: 'warningNotification',
  batchNumber: 'batchNumber',
  barCode: 'barCode',
  availabilityStatus: 'availabilityStatus',
  stockQuantity: 'stockQuantity',
  expiryDate: 'expiryDate',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type TradeNameScalarFieldEnum = (typeof TradeNameScalarFieldEnum)[keyof typeof TradeNameScalarFieldEnum]


export const CompanyScalarFieldEnum = {
  id: 'id',
  name: 'name',
  contactInfo: 'contactInfo',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


export const ContractingCompanyScalarFieldEnum = {
  id: 'id',
  title: 'title',
  companyId: 'companyId',
  contractingDate: 'contractingDate',
  expiryDate: 'expiryDate',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ContractingCompanyScalarFieldEnum = (typeof ContractingCompanyScalarFieldEnum)[keyof typeof ContractingCompanyScalarFieldEnum]


export const ContractingCompanyTradeNameScalarFieldEnum = {
  id: 'id',
  contractingCompanyId: 'contractingCompanyId',
  tradeNameId: 'tradeNameId',
  createdAt: 'createdAt'
} as const

export type ContractingCompanyTradeNameScalarFieldEnum = (typeof ContractingCompanyTradeNameScalarFieldEnum)[keyof typeof ContractingCompanyTradeNameScalarFieldEnum]


export const PrescriptionScalarFieldEnum = {
  id: 'id',
  doctorId: 'doctorId',
  patientId: 'patientId',
  tradeNameId: 'tradeNameId',
  status: 'status',
  prescriptionDate: 'prescriptionDate',
  validFrom: 'validFrom',
  validUntil: 'validUntil',
  dosage: 'dosage',
  frequency: 'frequency',
  duration: 'duration',
  instructions: 'instructions',
  maxRefills: 'maxRefills',
  currentRefillCount: 'currentRefillCount',
  notes: 'notes',
  version: 'version',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type PrescriptionScalarFieldEnum = (typeof PrescriptionScalarFieldEnum)[keyof typeof PrescriptionScalarFieldEnum]


export const PrescriptionVersionScalarFieldEnum = {
  id: 'id',
  prescriptionId: 'prescriptionId',
  version: 'version',
  changes: 'changes',
  changedBy: 'changedBy',
  createdAt: 'createdAt'
} as const

export type PrescriptionVersionScalarFieldEnum = (typeof PrescriptionVersionScalarFieldEnum)[keyof typeof PrescriptionVersionScalarFieldEnum]


export const DrugInteractionAlertScalarFieldEnum = {
  id: 'id',
  prescriptionId: 'prescriptionId',
  interactingMedicineId: 'interactingMedicineId',
  interactionType: 'interactionType',
  severity: 'severity',
  message: 'message',
  acknowledgedByDoctor: 'acknowledgedByDoctor',
  acknowledgedByPatient: 'acknowledgedByPatient',
  acknowledgedAt: 'acknowledgedAt',
  createdAt: 'createdAt'
} as const

export type DrugInteractionAlertScalarFieldEnum = (typeof DrugInteractionAlertScalarFieldEnum)[keyof typeof DrugInteractionAlertScalarFieldEnum]


export const NotificationScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  type: 'type',
  title: 'title',
  message: 'message',
  isRead: 'isRead',
  readAt: 'readAt',
  deliveryStatus: 'deliveryStatus',
  createdAt: 'createdAt'
} as const

export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


export const AuditLogScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  action: 'action',
  entityType: 'entityType',
  entityId: 'entityId',
  changes: 'changes',
  ipAddress: 'ipAddress',
  userAgent: 'userAgent',
  createdAt: 'createdAt'
} as const

export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


export const SessionScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  token: 'token',
  refreshToken: 'refreshToken',
  expiresAt: 'expiresAt',
  ipAddress: 'ipAddress',
  userAgent: 'userAgent',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]



/**
 * Field references
 */


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'UserRole'
 */
export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


/**
 * Reference to a field of type 'UserRole[]'
 */
export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'Decimal'
 */
export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


/**
 * Reference to a field of type 'Decimal[]'
 */
export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'SubscriptionStatus'
 */
export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


/**
 * Reference to a field of type 'SubscriptionStatus[]'
 */
export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


/**
 * Reference to a field of type 'PaymentStatus'
 */
export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


/**
 * Reference to a field of type 'PaymentStatus[]'
 */
export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


/**
 * Reference to a field of type 'AgeClassification'
 */
export type EnumAgeClassificationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgeClassification'>
    


/**
 * Reference to a field of type 'AgeClassification[]'
 */
export type ListEnumAgeClassificationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgeClassification[]'>
    


/**
 * Reference to a field of type 'Gender'
 */
export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


/**
 * Reference to a field of type 'Gender[]'
 */
export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


/**
 * Reference to a field of type 'DiseaseStatus'
 */
export type EnumDiseaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiseaseStatus'>
    


/**
 * Reference to a field of type 'DiseaseStatus[]'
 */
export type ListEnumDiseaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiseaseStatus[]'>
    


/**
 * Reference to a field of type 'AllergySeverity'
 */
export type EnumAllergySeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AllergySeverity'>
    


/**
 * Reference to a field of type 'AllergySeverity[]'
 */
export type ListEnumAllergySeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AllergySeverity[]'>
    


/**
 * Reference to a field of type 'RelationshipType'
 */
export type EnumRelationshipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RelationshipType'>
    


/**
 * Reference to a field of type 'RelationshipType[]'
 */
export type ListEnumRelationshipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RelationshipType[]'>
    


/**
 * Reference to a field of type 'AppointmentStatus'
 */
export type EnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus'>
    


/**
 * Reference to a field of type 'AppointmentStatus[]'
 */
export type ListEnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus[]'>
    


/**
 * Reference to a field of type 'DiseaseSeverity'
 */
export type EnumDiseaseSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiseaseSeverity'>
    


/**
 * Reference to a field of type 'DiseaseSeverity[]'
 */
export type ListEnumDiseaseSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiseaseSeverity[]'>
    


/**
 * Reference to a field of type 'WarningSeverity'
 */
export type EnumWarningSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WarningSeverity'>
    


/**
 * Reference to a field of type 'WarningSeverity[]'
 */
export type ListEnumWarningSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WarningSeverity[]'>
    


/**
 * Reference to a field of type 'MedicineAvailabilityStatus'
 */
export type EnumMedicineAvailabilityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MedicineAvailabilityStatus'>
    


/**
 * Reference to a field of type 'MedicineAvailabilityStatus[]'
 */
export type ListEnumMedicineAvailabilityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MedicineAvailabilityStatus[]'>
    


/**
 * Reference to a field of type 'PrescriptionStatus'
 */
export type EnumPrescriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrescriptionStatus'>
    


/**
 * Reference to a field of type 'PrescriptionStatus[]'
 */
export type ListEnumPrescriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrescriptionStatus[]'>
    


/**
 * Reference to a field of type 'InteractionSeverity'
 */
export type EnumInteractionSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InteractionSeverity'>
    


/**
 * Reference to a field of type 'InteractionSeverity[]'
 */
export type ListEnumInteractionSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InteractionSeverity[]'>
    


/**
 * Reference to a field of type 'NotificationType'
 */
export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


/**
 * Reference to a field of type 'NotificationType[]'
 */
export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
}
export type GlobalOmitConfig = {
  user?: Prisma.UserOmit
  pricingPlan?: Prisma.PricingPlanOmit
  subscription?: Prisma.SubscriptionOmit
  payment?: Prisma.PaymentOmit
  patient?: Prisma.PatientOmit
  medicalHistory?: Prisma.MedicalHistoryOmit
  familyHistory?: Prisma.FamilyHistoryOmit
  lifestyle?: Prisma.LifestyleOmit
  allergy?: Prisma.AllergyOmit
  doctor?: Prisma.DoctorOmit
  patientDoctor?: Prisma.PatientDoctorOmit
  consultation?: Prisma.ConsultationOmit
  appointment?: Prisma.AppointmentOmit
  disease?: Prisma.DiseaseOmit
  patientDisease?: Prisma.PatientDiseaseOmit
  activeSubstance?: Prisma.ActiveSubstanceOmit
  diseaseActiveSubstanceWarning?: Prisma.DiseaseActiveSubstanceWarningOmit
  medicineAlternative?: Prisma.MedicineAlternativeOmit
  tradeName?: Prisma.TradeNameOmit
  company?: Prisma.CompanyOmit
  contractingCompany?: Prisma.ContractingCompanyOmit
  contractingCompanyTradeName?: Prisma.ContractingCompanyTradeNameOmit
  prescription?: Prisma.PrescriptionOmit
  prescriptionVersion?: Prisma.PrescriptionVersionOmit
  drugInteractionAlert?: Prisma.DrugInteractionAlertOmit
  notification?: Prisma.NotificationOmit
  auditLog?: Prisma.AuditLogOmit
  session?: Prisma.SessionOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

